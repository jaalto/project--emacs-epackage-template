#!/bin/sh
#
#   Copyright
#
#       Copyright (C) 2011-2012 Jari Aalto <jari.aalto@cante.net>
#
#   License
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program. If not, see <http://www.gnu.org/licenses/>.
#
#   Install
#
#       Source this file on command line or from POSIX shell startup file:
#
#           . <this file's name>
#
#   Requirements
#
#       You must have GNU programs (grep etc.) in PATH first
#       You must know Emacs Lisp Programming
#       You must know Git well (branching, merging etc.)
#       You must have epackage.el installed, see
#       <http://www.emacswiki.org/emacs/DELPS#toc6>
#
#   Decription
#
#       Shell command line functions for Distributed Emacs Lisp Package
#       Management <http://www.emacswiki.org/emacs/DELPS>. Updates to this
#       file are available at
#       <https://github.com/jaalto/project--emacs-epackage-template>. Please
#       familiarize yourself with the procedure by reading README at the above
#       site first before using this file's helper functions.
#
#       In simplest case, the steps to start creating epackage:
#
#       1. You have epackage.el downloaded and stored in ~/.emacs.d
#       2. You have the URL to lisp file you want to package (EmacsWiki.org)
#       3. Make empty directory, name does not matter. Cd into it.
#       4. Import code to Git repository from URL
#
#           Egit <URL>
#
#           Follow the displayed instructions to commit and tag.
#           If you don't see obvious version number, you must open the *.el
#           in $EDITOR and examine what might be the last modified date
#           and version number.
#
#           After this step, you have imported raw upstream code is in
#           Git "upstream" branch.
#
#       5.  Create "master" branch (as instructed by "Egit" output above):
#
#           git git checkout -b master
#
#       6.  Generate template files:
#
#           Edir <PACKAGE-NAME> <FILE>.el
#
#       7.  Edit the generated files in epackage/ dir and commit.
#
#           cd epackage/
#           .. edit files
#           .. remove files if not relevant (*-compile.el etc.).
#           git add .
#           git commit -m "epackage/: new"
#
#       8.  Create repository at Github, and push
#
#           git remote add github <your repository URL>
#           git push github upstream master
#           git push github --tags
#
#       9   Last, contact Sources List maintainer to have your epackage
#           URL included.

Ever ()
{
    local help
    help="\
SYNOPSIS
    Ever

DESCRIPTION
    Epackage version information

    Grep lines looking like REQUIRE, DATE, EMAIL, URL, VERSION from all
    Emacs Lisp files recursively from current directory."

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
    esac

    # Package-Requires is ELPA header.
    # See http://marmalade-repo.org/doc-files/package.5.html

    find -type f -name "*.el" |
    xargs \
    egrep -i '\<v[0-9]+\.|version|[a-z0-9]@[a-z]|http:/|git:/|\(require |\<20[0-1][0-9]|Package-Requires' |
    egrep -iv 'emacs-(major-|minor-)?version|%s|(lat|eith)er version|version( of|\))|\(version' |
    egrep -iv '; *\(require|\"\(require|[\[\"]http|http-version|version of|www.gnu.org' |
    egrep -iv 'mime-version'
}


E_lisp ()
{
    local file

    if [ "$EPACKAGE_ROOT" ]; then
        file="$EPACKAGE_ROOT/epackage.el"

        if [ ! -f "$file" ]; then
            echo "[ERROR] Invalid $EPACKAGE_ROOT, not such file: $list" >&2
            return 1
        fi

    else # Try to guess
        file=$(find $HOME/.emacs.d -maxdepth 3 \
               -type f -name epackage.el 2> /dev/null)
    fi

    if [ ! "$file" ]; then
        echo "[ERROR] \$EPACKAGE_ROOT not set to directory of epackage.el" >&2
        return 1
    fi

    echo "$file"
}

Elint ()
{
    local help
    help="\
SYNOPSIS
    Elist [options] file.el ...

DESCRIPTION
    Lint Emacs Lisp files for Quality assurance violations.

    Examine each *.el to find ay deviations from guidelines know
    to writng Emacs extensions. Startdard Emacs check include
    lisp-mnt.el, chekdoc.el, elint.el and byte compilation.

OPTIONS
    -t, --test  Run in test mode. Do now actually execute commands.

BUGS
    Linting will take considerable amount of time. This is mostly due
    to elint.el, which examines call syntaxes. It has to collect
    function call information by opening *.el.gz files in Emacs
    distribution to cache results before it can check used calls. This
    is *slow*.

ENVIRONMENT

    EPACKAGE_ROOT
        Directory location of epackage.el file to use. By default Various
        locations under ~/.emacs.d are tried.

STANDARDS

    Emacs Lisp Software Quality Assurance (QA) related links:
    http://pinboard.in/u:jariaalto/t:emacs/t:elisp/t:qa"

    unset test

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
        -t | --test)
            test="test"
            shift
            ;;
    esac

    local lisp
    lisp=$(E_lisp)

    [ "$lisp" ] || return 1

    if [ ! "$1" ]; then
        echo "[ERROR] Missing Emacs Lisp file(s) to lint" >&2
        return 1
    fi

    local file
    file="${TMPDIR:-/tmp}/Egit.${LOGNAME:-${NAME:-foo}}.$$.lint.tmp"

    ${test+echo} ${EPACKAGE_EMACS:-emacs} \
        -quick \
        --batch \
        --debug-init \
        --load "$lisp" \
        --funcall epackage-batch-devel-lint-lisp \
        "$@" > "$file" 2>&1

    [ "$test" ] && return 0

    if ! egrep --after-context=10000 '^\*\*\* Lint' "$file" ; then
        # Error happened
        unset test

        cat "$file"
        rm -f "$file"

        return 2
    fi

    rm -f "$file"
    unset test
}

Edir ()
{
    local help
    help="\
SYNOPSIS
    Edir [options] <PACKAGE NAME> NAME.el

DESCRIPTION
    Epackage directory populate (epackage/)

    Examine *.el to find information about license, upstream email
    etc. and write template files to epackage/ directory (will be
    created). This command is suitable only for packages that consist
    of only one single Emacs Lisp file.

    Good naming conventions help in organizing and managing packages.
    Rules for selecting PACKAGE NAME:

    - Use <NAME>-mode if the package is a major or minor mode.
      An example: python.el => python-mode.
    - use lib-<NAME> if package is meant to be a library.
      An example: date-calc.el => lib-date-calc

    Special case:

    - If PACKAGE NAME is sama as FILE, the extension is removed.
      This helps working on the command where TAB can be used
      complete file names.

OPTIONS
    -t, --test  Run in test mode. Do now actually execute commands.

EXAMPLES
    Generate templates for regular file:

        Edir toggle.el toggle.el

    Generate templates for a library package:

        Edir lib-date-calc date-calc.el

ENVIRONMENT

    EPACKAGE_EMACS
        Path to emacs binary to use. Defaults to \"emacs\".

    EPACKAGE_ROOT
        Directory location of epackage.el file to use. By default Various
        locations under ~/.emacs.d are tried.

STANDARDS
   The Epackage primer
   <https://github.com/jaalto/project--emacs-epackage-template>."

    unset test

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
        -t | --test)
            test="test"
            shift
            ;;
    esac

    local lisp
    lisp=$(E_lisp)

    [ "$lisp" ] || return 1

    local package
    package=$(echo "$1" | sed "s/\.el$//")

    local file
    file=$2

    if [ ! "$package" ]; then
        echo "[ERROR] Argument 1 missing (package NAME)." >&2
        return 1
    fi

    if [ ! "$file" ]; then
        echo "[ERROR] Argument 2 missing (*.el FILE)." >&2
        return 1
    fi

    case "$file" in
        */*.el)
            ;;
        *.el)
            file="./$file"              # Must have path
            ;;
        *)
            echo "[ERROR] *.el expected, instead of $file" >&2
            return 1
            ;;
    esac

    ${test+echo} ${EPACKAGE_EMACS:-emacs} \
        -quick \
        --batch \
        --debug-init \
        --load "$lisp" \
        --funcall epackage-batch-devel-compose-package-dir \
        $package \
        "$file"

    unset test
}

Egit_indate ()
{
    local help

    help="\
SYNOPSIS
    Egit_indate [options] FILE

DESCRIPTION
    Return internal modified date by examing contents of FILE."

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
    esac

    if [ ! "$1" ]; then
        echo "[ERROR]: Missing FILE" >&2
        return 2
    fi

    # Time-stamp: <2010-02-02 19:37:18 UTC logname>
    set -- $(egrep -i --only-matching --max-count=1 \
             "^;+ +(Time-Stamp|Last[ -](Modified|Updated)): +<....-..-.." "$file")

    if [ "$3" ]; then
        echo $3 | sed "s/^.//"          # The leading "<"
        return 0
    fi

    return 1
}

Egit_filedate ()
{
    local help

    help="\
SYNOPSIS
    Egit_filedate [options] FILE

DESCRIPTION
    Return ISO 8601 date of FILE."

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
    esac

    if [ ! "$1" ]; then
        echo "[ERROR]: Missing FILE" >&2
        return 2
    fi

    perl -e '$mtime = (stat shift @ARGV)[9];
             ($y, $m, $d) = (localtime $mtime)[5,4,3];
             $y += 1900;
             printf( qq(%d-%02d-%02d), $y, $m, $d);
             ' \
             "$file"
}

Egit_version ()
{
    local help

    help="\
SYNOPSIS
    Egit_version [options] FILE

DESCRIPTION
    Return version of FILE."

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
    esac

    if [ ! "$1" ]; then
        echo "[ERROR]: Missing FILE" >&2
        return 2
    fi

    # Search for standard line ";; Version: 3.0"

    set -- $(egrep --only-matching --max-count=1 \
             "^;+ +Version: *[^ ]+" "$1" )

    if [ "$3" ]; then
        echo $3
        return 0
    fi

    return 1
}

Egit ()
{
    local help
    help="\
SYNOPSIS
    Egit [options] [URL]

DESCRIPTION
    Epackage git import.

    Import source code (Emacs Lisp *.el) into epackage Git repository.
    The URL can be http:// to a single *.el file or git:// locations
    of upstream code. If URL is not given, it is expected that the
    upstream code is already in current directory.

    This command only prepares for the initial import to Git
    \"upstream\" branch. From there the steps needed are:

    - commit (to upstream branch)
    - tag the upstream branch
    - create "master" branch off upstream
    - populate epackage/ directory. See command \"Edir\".

    The URL can be in format:

    - Standard http:// or git:// protocol
    - ew:file.el; file is retrieved from EmacsWiki.

OPTIONS
    -t, --test  Run in test mode. Do now actually execute commands.

EXAMPLES
    You have a direct URL to the Emacs Lisp file. Import it:

        Egit http://www.emacswiki.org/emacs/download/<filename>.el

    Upstream uses Git repository for Emacs Lisp source code. Import it:

        Egit git://github.com/USER/PROJECT.git

    The sources are in the currect directory; unpacked. Import them:

        Egit

STANDARDS
   The Epackage primer
   <https://github.com/jaalto/project--emacs-epackage-template>."

    unset test

    case "$1" in
        -h | --help )
            echo "$help"
            return 0
            ;;
        -t | --test)
            test="test"
            shift
            ;;
    esac

    local url
    url=$1

    if [ -d .git ]; then
        echo "[ERROR] .git exists" >&2
        return 1
    fi

    local empty
    empty="empty"

    local files

    if find . -type f | grep  '.' ; then
        empty=""
    fi

    local giturl
    local wget

    case "$url" in
        ew:*)
            wget="wget"
            url=$(echo $url | sed "s/^ew://")
            url="http://www.emacswiki.org/emacs/download/$url"
            ;;
        http:/* )
            wget="wget"
            ;;
        git://* | *.git)
            giturl="$url"
            url=""
            ;;
        *[a-z]*)
            echo "[ERROR] Not a valid URL: $url" >&2
            return 1
            ;;
    esac

    if [ "$wget" ]; then
        ${test:+echo} wget "$url" || return $?
        empty=""
        wget=$(basename $url)
    fi

    local date
    date=$(date "+%Y-%m-%d")

    local debug
    local file
    file="${TMPDIR:-/tmp}/Egit.${LOGNAME:-${NAME:-foo}}.$$.tmp"

    if [ "$giturl" ]; then

        debug="Action: Git"

        if [ ! "$empty" ]; then
            echo "[WARN] Directory not empty. Press (C-c) to abort" >&2
            read
        fi

        ${test:+echo} git init
        ${test:+echo} git symbolic-ref HEAD refs/heads/upstream

        rm -f .gitignore
        ${test:+echo} touch .ignore
        ${test:+echo} git add .ignore
        ${test:+echo} git commit -m "add .ignore"

        ${test:+echo} git remote add upstream $giturl
        ${test:+echo} git fetch upstream
        ${test:+echo} git checkout --track -b upstream-master upstream/master

        ${test:+echo} git checkout upstream
        ${test:+echo} git merge upstream-master

        ${test:+echo} git rm .ignore
        ${test:+echo} git commit -m "rm .ignore"

        ${test:+echo} git checkout -b master upstream

        ${test:+echo} git checkout upstream

        Ever | tee "$file"

        local version
        version=$(Egit_version "$file")
        [ "$version" ] || version="VERSION"

        # Show last commits (upstream)

        git log --max-count=5 --date=short --pretty='format:%h %ci %s' |
        sed "s/^/#GIT /"

        # We know that upstream commit is at 4th backward
        # git merge-base upstream/master HEAD | cut -c1-7
        #
        # SHA DATE TIME TZ
        set -- $(git log --skip=3 --max-count=1 \
                 --date=short --pretty='format:%h %ci')

        echo
        echo "# WHAT YOU NEED TO DO NEXT:"
        echo "# Examine information and correct commands below."

        # User must fill in the VERSION

        echo "git tag upstream/$2--$version-git-$1"

    elif [ "$wget" ]; then

        debug="Action: URL"

        ${test:+echo} git init
        ${test:+echo} git symbolic-ref HEAD refs/heads/upstream

        ${test:+echo} git add -A

        local version

        Ever | tee "$file"

        local VERSIONOK
        local version
        version=$(Egit_version "$file")

        if [ "$version" ]; then
            VERSIONOK="eval"
        else
            version="VERSION"
        fi

        local fdate
        fdate=$date
        fdate=$(Egit_indate "$file" || Egit_filedate "$file")

        rm -f "$file"

        [ "$test" ] && fdate="YYYY-MM-DD"

        [ "$test" ] || ls -l

        if [ ! "$VERSIONOK" ]; then
            echo "# WHAT YOU NEED TO DO NEXT:"
            echo "# Examine information and correct commands below."
        fi

        ${VERSIONOK:-echo} "git commit -m 'Import upstream $date from $url'"
        ${VERSIONOK:-echo} "git tag upstream/$fdate--$version"

        if [ "$VERSIONOK" ]; then
            git tag                     # Show what we set tag to
        fi

        ${VERSIONOK:-echo} git checkout -b master

        unset VERSIONOK

    else

        debug="Action: ELSE"

        if [ "$empty" ]; then
            echo "[WARN] No files. Create upstream branch (C-c to abort)" >&2
            read
        fi

        ${test:+echo} git init
        ${test:+echo} git symbolic-ref HEAD refs/heads/upstream
        ${test:+echo} git add .

        Ever

        for file in $(ls *.el 2> /dev/null)
        do
            echo "# $file"
            Egit_version "$file"
            Egit_indate "$file" || Egit_filedate "$file"
        done

        echo
        echo "# WHAT YOU NEED TO DO NEXT:"
        echo "# Examine information and correct commands below."

        echo "git commit -m 'Import upstream $date from ...'"
        echo "git tag upstream/YYYY-MM-DD--N.N"
        echo git checkout -b master

    fi

    unset test
}

# End of file
